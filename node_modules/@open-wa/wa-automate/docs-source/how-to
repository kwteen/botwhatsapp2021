# Location

## Sending Location

[[sendLocation]]

```javascript
    client.sendLocation(chatId, latitude, longitude, 'London!')
```

## Receiving Location

Check the [[Message]] reference to learn how to extract the coordinates from a location message

```javascript
    client.onMessage(message=> {
        if(message.type==="location") {
            //Using destructuring
            const {
                // The text associated with the location
                loc,
                //Latitude
                lat,
                //Longitude
                lng
            } = message
        }
    })
```

## Listening to Live Locations

[[onLiveLocation]] fires a [[LiveLocationChangedEvent]] event. [[onLiveLocation]] requires a chat id to listen to so you need to detect exactly when a chat starts sharing a live location with your host account. This example detects when a live location is started and then registers a new callback to listen to updates in that live location session.

```javascript
    const liveLocationCallback = currentLiveLocation => {
        console.log('Live location update', currentLiveLocation.id, currentLiveLocation.lat, currentLiveLocation.lng);
    }
    client.onMessage(message=> {
        //This is how to detect when someone has started a live location with you
        if(message.shareDuration){
            client.onLiveLocation(message.from, liveLocationCallback)
        }
    })

```

### Forcing Live Locations to Update

The updates of live locations are very passive. If you require updates at regular intervals then you can force it using [[forceUpdateLiveLocation]]. It is recomended to keep an array of chat ids that have live location sessions and map through them at regular intervals

```javascript
    await client.forceUpdateLiveLocation(chatId);

    //or force update live locations of multiple chats
    await Promise.all([
        'chatId1',
        'chatId2'
    ].map(client.forceUpdateLiveLocation));
```

# Manage Participants

[[addParticipant]] - add a participant
[[removeParticipant]] -  remove a particpant
[[promoteParticipant]] - Make a participant admin
[[demoteParticipant]] -  remove participant as admin

```javascript
...
  client.addParticipant('XXXXXXX-YYYYYY@c.us','ZZZZZZZZZ@c.us')
  client.removeParticipant('XXXXXXX-YYYYYY@c.us','ZZZZZZZZZ@c.us')
  client.promoteParticipant('XXXXXXX-YYYYYY@c.us','ZZZZZZZZZ@c.us')
  client.demoteParticipant('XXXXXXX-YYYYYY@c.us','ZZZZZZZZZ@c.us')
...
```

# More examples

## Simulate typing

As of version 1.3.1 you can now simulate '...typing'

You need to pass the following params:

- chat id: xxxxx@c.us
- on: true or false

Note: You need to manually turn this off!!!

```javascript
//start '...typing'
await client.simulateTyping('xxxxx@c.us',true)
//wait 3 seconds

//stop '...typing'
await client.simulateTyping('xxxxx@c.us',false)
```

## Load profile pics from server

Generally, after the 20th chat in your WA, getChat methods do not retreive the chat picture. You need to get these from the WA servers. This is how you do it in v1.6.6^:

```javascript
client.getProfilePicFromServer('XXXXXXX-YYYYY@c.us')
```

## Listen to Read Receipts

As of version 1.5.3 you can now listen in on the read state (or technically acknowledgement state) of the messages. As of writing the limitation is presumed to be on sent messages.

The callback you set returns the whole raw message object.

Here's how you do it.

```javascript
client.onAck((msg:any) => console.log(msg.id.toString(),msg.body,msg.ack))
```

ack represents the acknoledgement state, of which there are 3.

```javascript
1 => Message Sent (1 tick)

2 => Message Received by Recipient (2 ticks)

3 => Message Read Receipt Confirmed (2 blue ticks)
```

Note: You won't get 3 if the recipient has read receipts off.

# Reacting To Group Events

For a specific group you can use [[onParticipantsChanged]], this will fire all detectable group participant change events (see: [[ParticipantChangedEventModel]]).

```javascript
import {
  create,
  Client,
  ParticipantChangedEventModel,
} from "@open-wa/wa-automate";

function start(client: Client) {
  const groupChatId = "00000000000-11111111111@g.us";
  client.onParticipantsChanged(
    groupChatId,
    async (changeEvent: ParticipantChangedEventModel) => {
      if (changeEvent.action == "add") {
        // It is possible that multiple accounts get added
        await Promise.all(
          changeEvent.who.map((number) =>
            client.sendTextWithMentions(
              groupChatId,
              `@${number} has been added!`
            )
          )
        );
      }
      if (changeEvent.action == "remove") {
        // It is possible that multiple accounts get removed
        //remember: all client methods are promises!
        await Promise.all(
          changeEvent.who.map((number) =>
            client.sendTextWithMentions(
              groupChatId,
              `@${number} has been removed!`
            )
          )
        );
      }
    }
  );
}

create().then((client) => start(client));
```

## Listening to participant change events from all groups

If you want to listen to participant change requests from all groups, you can get a list of all groups [[getAllChatIds]], filter for groups `.filter(id=>id.includes('@g.us')` then use the above method. However this results in multiple listeners in the browser and can have detrimental performance implications.

For better performance and stability you can use the Insiders Feature [[onGlobalParicipantsChanged]].

```javascript
import {
  create,
  Client,
  ParticipantChangedEventModel,
} from "@open-wa/wa-automate";

function start(client: Client) {
  client.onGlobalParicipantsChanged(
    async (changeEvent: ParticipantChangedEventModel) => {
      if (changeEvent.action == "add") {
        // It is possible that multiple accounts get added
        await Promise.all(
          changeEvent.who.map((number) =>
            client.sendTextWithMentions(
              changeEvent.chat,
              `@${number} has been added!`
            )
          )
        );
      }
      if (changeEvent.action == "remove") {
        // It is possible that multiple accounts get removed
        //remember: all client methods are promises!
        await Promise.all(
          changeEvent.who.map((number) =>
            client.sendTextWithMentions(
              changeEvent.chat,
              `@${number} has been removed!`
            )
          )
        );
      }
    }
  );
}

create().then((client) => start(client));
```


# Receiving Messages

## Listen to only incoming messages

[[onMessage]]

```javascript
    client.onMessage(message=>{
        console.log(message.body);
    })
```

## Listen to all messages in and out

[[onAnyMessage]]

```javascript
    client.onAnyMessage(message=>{
        console.log(message.body);
    })
```
# SendFile


# Sending Files

## Send Image

[[sendImage]]

Make sure to use a [[DataURL]] for the second parameter.

```javascript
    client.sendImage(chatId, dataUrl, 'filename.jpeg', 'cool caption')

    //send image as a reply to another message quotedMessageId
    client.sendImage(chatId, dataUrl, 'filename.jpeg', 'cool caption', quotedMessageId)

    //wait for the Id to be returned
    client.sendImage(chatId, dataUrl, 'filename.jpeg', 'cool caption', null, true)

```

## Send Audio

[[sendPtt]] sends an audio clip as a 'push to talk' type file. This allows recipients to play the clip as they would any other voice note.

```javascript
    client.sendFile(chatId, dataUrl)

    //Send the audio as reply to a message (quotedMessageId)
    client.sendFile(chatId, dataUrl, )quotedMessageId
```

## Send File

[[sendFile]]

[[sendFileFromUrl]]

```javascript

    client.sendFile(chatId, dataUrl, 'file.pdf', 'check this pdf')

    //Send the file as reply to a message (quotedMessageId)
    client.sendFile(chatId, dataUrl, 'file.pdf', 'check this pdf', quotedMessageId)

    //Send a file and wait for the message id to be returned
    client.sendFile(chatId, dataUrl, 'file.pdf', 'check this pdf', null, true)

    //or from URL
    client.sendFileFromUrl(chatId, url);
```

## Send Stickers

[[sendImageAsSticker]]

[[sendStickerfromUrl]]

```javascript
    client.sendImageAsSticker(chatId, dataUrl);

    //or from a URL
    client.sendStickerfromUrl(chatId, url);
```

## Sending Gifs

There are two ways to send GIFs - by Video or by giphy link.
  
  WA doesn't actually support the .gif format - probably due to how inefficient it is as a filetype - they instead convert GIFs to video then process them.

  In order to send gifs you need to do the same (convert the gif to an mp4 file) then use [[sendVideoAsGif]]

  [[sendGiphy]] is a convenience method to make it easier to send gifs from the website [GIPHY](https://giphy.com). You need to make sure you use a giphy media link as shown below.

```javascript

import { create, Client} from '@open-wa/wa-automate';

function start(client: Client) {
await client.sendVideoAsGif('xyz@c.us','Video FILE DATA URL','some file.mp4', `Hello this is the caption`);

//or send via Giphy URL

await client.sendGiphy('xyz@c.us','https://media.giphy.com/media/oYtVHSxngR3lC/giphy.gif', `Hello this is the caption`);
}

///IMPORTANT! Please make sure to point to your chrome installation and make sure your host has ffmpeg support
create({
  // For Mac:
  executablePath: '/Applications/Google Chrome.app/Contents/MacOS/Google Chrome',
  // For Windows:
  // executablePath: 'C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe',
}).then(client => start(client));

```

# Sending Messages

When sending a message, make sure to await the promise. It usually returns an id if the message was sent successfully.

## Send a basic message

[[sendText]]

```javascript
    await client.sendText(chatId, "Hello");
```

## Send a message with mentions

[[sendTextWithMentions]]

```javascript
    await client.sendTextWithMentions(chatId, "Hello");
```

## Send a reply

[[reply]]

```javascript
    await client.reply(chatId, "Hello", idOfMessageToReplyTo);

    // set the fourth variable to true to set the chat to 'seen'
    await client.reply(chatId, "Hello", idOfMessageToReplyTo, true);
```

## Send a reply with mentions

[[sendReplyWithMentions]]

```javascript
    await client.sendReplyWithMentions(chatId, "Hello", idOfMessageToReplyTo);
```

## Forward Messages

To forward messages use [[forwardMessages]] with the following params:

- chat to forward messages to : xxxxx@c.us
- messages: a single or array of message ids or message objects
- skipMyMessages: true or false, if true it will filter out messages sent by you from the list of messages, default false.

```javascript
//forward multiple messages using an array of messageIds
await client.forwardMessages('xxxxx@c.us',[Array of Message Ids],true)

//forward single message by id
await client.forwardMessages('xxxxx@c.us,"messageId",true)
```

# Send Video

In order to send videos, the client must be started with an instance of chrome! Otherwise videos will be sent as files and not render properly in the app.

To use chrome set [[useChrome]] (finds the chrome installation automatically) to true or set the [[executablePath]] (set the chrome installation path manually).

[[useChrome]] takes a few seconds so to save time in consequtive processes set [[executablePath]] ([[useChrome]] will output the valid [[executablePath]] in the logs so keep an eye on them)

```javascript
    client.sendImage(chatId, dataUrl, 'filename.jpeg', 'cool caption')

    //send image as a reply to another message quotedMessageId
    client.sendImage(chatId, dataUrl, 'filename.jpeg', 'cool caption', quotedMessageId)

    //wait for the Id to be returned
    client.sendImage(chatId, dataUrl, 'filename.jpeg', 'cool caption', null, true)

```

Example of config for sending videos:

```javascript
create({
  // For Mac:
  executablePath: '/Applications/Google Chrome.app/Contents/MacOS/Google Chrome',
  // For Windows:
  // executablePath: 'C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe',
}).then(client => start(client));
```

# Creating an API

There are multiple convinient ways to create an API.

1. Use the ready-made API via npx

Learn more here [[Easy API]]

2. Build your own API on express and just use the built in middleware

3. 

# Decrypting Media

Here is a sample of how to decrypt media. This has been tested on images, videos, documents, audio and voice notes.

```javascript
import { create, Client, decryptMedia } from '@open-wa/wa-automate';
const mime = require('mime-types');
const fs = require('fs');

function start(client: Client) {
  client.onMessage(async message => {
    if (message.mimetype) {
      const filename = `${message.t}.${mime.extension(message.mimetype)}`;
      const mediaData = await decryptMedia(message);
      const imageBase64 = `data:${message.mimetype};base64,${mediaData.toString(
        'base64'
      )}`;
      await client.sendImage(
        message.from,
        imageBase64,
        filename,
        `You just sent me this ${message.type}`
      );
      fs.writeFile(filename, mediaData, function(err) {
        if (err) {
          return console.log(err);
        }
        console.log('The file was saved!');
      });
    }
  });
}

create().then(client => start(client));
```

It is always preferable to keep projects smaller than needed so you can now use a lightweight library called wa-decrypt for projects that do not need all of @open-wa/wa-automate.

You can install that using:

```bash
> npm i --save wa-decrypt
```

and import it like so:

```javascript
import { decryptMedia } from 'wa-decrypt';
```

[Learn more about wa-decrypt here](https://github.com/smashah/wa-decrypt#readme)
# Detecting Logouts

First use [[onStateChanged]] to detect changes in the session state. Then use [[forceRefocus]] to force the the app to continue working. If `state` equals `UNPAIRED` that means the host account user has manually de authenticated the session through the app.

```javascript

  client.onStateChanged(state=>{
    console.log('statechanged', state)
    if(state==="CONFLICT" || state==="UNLAUNCHED") client.forceRefocus();

    if(state==='UNPAIRED') console.log('LOGGED OUT!!!!')
  });
```

# Group

## Create a Group

Use [[createGroup]] to create a new group, first parameter is the group name, the second parameter is the contact ids to add as participants. There needs to be at least one participant.

```javascript
...
  client.createGroup('Cool new group','xxxxxxxxx@c.us') //you can also send an array of ids.
...
```

## Managing Participants

[[addParticipant]] - add a participant
[[removeParticipant]] -  remove a particpant
[[promoteParticipant]] - Make a participant admin
[[demoteParticipant]] -  remove participant as admin

```javascript
...
  client.addParticipant('XXXXXXX-YYYYYY@c.us','ZZZZZZZZZ@c.us')
  client.removeParticipant('XXXXXXX-YYYYYY@c.us','ZZZZZZZZZ@c.us')
  client.promoteParticipant('XXXXXXX-YYYYYY@c.us','ZZZZZZZZZ@c.us')
  client.demoteParticipant('XXXXXXX-YYYYYY@c.us','ZZZZZZZZZ@c.us')
...
```

## Listening to participant changes of a specific group

You can react to when participants are added and removed. [[onParticipantsChanged]] emits a [[ParticipantChangedEventModel]].

```javascript
client.onParticipantsChanged("XXXXXXXX-YYYYYYYY@g.us", (participantChangedEvent) => console.log("participant changed for group", participantChangedEvent));

//participantChangedEvent returns
{
  by: 'XXXXXXXXXXX@c.us', //who performed the action
  action: 'remove',
  who: [ 'XXXXXXXXX@c.us' ] //all the numbers the action effects.
}
```

This solution can result in some false positives and misfires however a lot of effort has been made to mitigate this to a reasonable level. Best practice is to maintian a seperate registry of participants and go from that.

## Listen to participant changes globally

[[onGlobalParicipantsChanged]] is a simple and memory efficient way to listen to all participant changes from all groups. This is an Insider's Feature.

```javascript
client.onGlobalParicipantsChanged((participantChangedEvent) => console.log("participant changed for group", participantChangedEvent));

//participantChangedEvent returns
{
  by: 'XXXXXXXXXXX@c.us', //who performed the action
  action: 'remove',
  who: [ 'XXXXXXXXX@c.us' ] //all the numbers the action effects.
}
```

# Error Handling

## Keep your promises!

Treat all `client` methods as promises. Therefore make sure to await them and wrap them in `try/catch` blocks

```javascript
    client.onMessage(async message => {
        try{
            //respond with 'Hi!'
            await client.sendText(message.from, 'Hi!');
        } catch(error){
            console.log(error);
        }
    })

```

## Error handling on `create`

The [[create]] method itself is a promise so you can handle errors using a try catch block here also from which you can choose to try again or exit the process.

```javascript
async function start(client){
    ...
}

async function launch(){
    try{
        const client = await create();
        await start(client);
    } catch(error){
        console.log(errror)
    }
}

launch();

```

Alternatively, you can set the client "start" function (the function that consumes the client after it has been created) as a config variable [[restartOnCrash]], allowing the process itself to restart/retry if there are any issues. Be careful with this as it may lead to an endless loop.

You can also use [[logConsole]] (logs all browser console output) or just [[logConsoleErrors]] (only logs browser errors) to better debug issues.

Setting [[killProcessOnBrowserClose]] to true will kill the whole node process upon any critical browser issue (maybe the browser runs out of memory and crashes, this option will kill the process).

This is useful if you have a n orchestrator process that restarts processes. (e.g [pm2](https://pm2.keymetrics.io/) or a [docker restart policy](https://docs.docker.com/config/containers/start-containers-automatically/#:~:text=Restart%20policy%20details,-Keep%20the%20following&text=A%20restart%20policy%20only%20takes,going%20into%20a%20restart%20loop.))

```javascript
async function start(client){
    ...
}

async function launch(){
    try{
        const client = await create({
            //sets restartOnCrash to the above `start` function
            restartOnCrash: start,

            //log all browser console output
            logConsole: true,

            //or just browser errors
            logConsoleErrors: true,

            //kill the process if the browser crashes/is closed manually
            killProcessOnBrowserClose: true
        });
        await start(client);
    } catch(error){
        console.log(error)
    }
}

launch();
```

## Manage page errors

Since this project is built upon puppeteer, you can access the [Puppeteer Page](https://pptr.dev/#?product=Puppeteer&version=v2.0.0&show=api-class-page) instance by referencing `client.getPage()`, and then therefore you can listen to any errors on the page like so:

```javascript
client.getPage().on('error', _=>{
...
}
```

## Kill the session

As of v1.6.6^ you can now kill the session when required. Best practice is to manage trycatch-es yourself and kill the client on catch.

```javascript
try{
...
await client.sendMessage(...
...
} catch(error){
client.kill();
//maybe restart the session then
}
```

# Handle Incoming Call

[[onIncomingCall]] emits a [[Call]] object. You can use this to tell people not to call the number

```javascript
    client.onIncomingCall(async call=>{
        await client.sendText(call.peerJid._serialized, 'Sorry I cannot accept calls');
    });
```
