The MIT License (MIT)

Copyright (c) 2016 Matheus Fernandes – http://matheus.top – hi@matheus.top

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
{
  "name": "@vitalets/google-translate-api",
  "version": "4.0.0",
  "description": "A free and unlimited API for Google Translate",
  "main": "index.js",
  "scripts": {
    "test": "xo && nyc ava",
    "coverage": "nyc report --reporter=text-lcov | coveralls && nyc report --reporter=text-lcov > coverage.lcov && codecov",
    "release": "npm test && npm version $VER && npm publish",
    "postrelease": "git push --follow-tags --no-verify",
    "release-patch": "VER=patch npm run release",
    "release-minor": "VER=minor npm run release"
  },
  "husky": {
    "hooks": {
      "pre-commit": "xo",
      "pre-push": "npm test"
    }
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/vitalets/google-translate-api.git"
  },
  "keywords": [
    "translate",
    "translator",
    "google",
    "translate",
    "api",
    "free",
    "language"
  ],
  "author": {
    "name": "Matheus Fernandes",
    "email": "npm@matheus.top",
    "url": "http://matheus.top"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/vitalets/google-translate-api/issues"
  },
  "homepage": "https://github.com/vitalets/google-translate-api#readme",
  "dependencies": {
    "@vitalets/google-translate-token": "^1.2.0",
    "configstore": "^5.0.1",
    "got": "^9.6.0"
  },
  "devDependencies": {
    "ava": "^0.15.2",
    "codecov": "^1.0.1",
    "coveralls": "^2.11.11",
    "husky": "^3.0.4",
    "nyc": "^7.0.0",
    "xo": "^0.16.0"
  },
  "xo": {
    "space": 4
  }
}

# google-translate-api
[![Build Status](https://travis-ci.org/vitalets/google-translate-api.svg?branch=master)](https://travis-ci.org/vitalets/google-translate-api)
[![NPM version](https://img.shields.io/npm/v/@vitalets/google-translate-api.svg)](https://www.npmjs.com/package/@vitalets/google-translate-api)
[![XO code style](https://img.shields.io/badge/code_style-XO-5ed9c7.svg)](https://github.com/sindresorhus/xo)
[![Coverage Status](https://coveralls.io/repos/github/vitalets/google-translate-api/badge.svg?branch=master)](https://coveralls.io/github/vitalets/google-translate-api?branch=master)

A **free** and **unlimited** API for Google Translate :dollar::no_entry_sign: for Node.js.

## Features 

- Auto language detection
- Spelling correction
- Language correction 
- Fast and reliable – it uses the same servers that [translate.google.com](https://translate.google.com) uses

## Why this fork?
This fork of original [matheuss/google-translate-api](https://github.com/matheuss/google-translate-api) contains several improvements:

- New option `client="t|gtx"`. Setting `client="gtx"` seems to work even with outdated token, see [this discussion](https://github.com/matheuss/google-translate-api/issues/79#issuecomment-425679193) for details
- Fixed extraction of TKK ceed from current `https://translate.google.com` sources (via [@vitalets/google-translate-token](https://github.com/vitalets/google-translate-token))
- Removed unsecure `unsafe-eval` dependency (See [#2](https://github.com/vitalets/google-translate-api/pull/2))
- Added [daily CI tests](https://travis-ci.org/vitalets/google-translate-api/builds) to get notified if Google API changes
- Added support for custom `tld` (especially to support `translate.google.cn`, see [#7](https://github.com/vitalets/google-translate-api/pull/7))
- Added support for outputting pronunciation (see [#17](https://github.com/vitalets/google-translate-api/pull/17))
- Added support for custom [got](https://github.com/sindresorhus/got) options. It allows to use proxy and bypass request limits (see [#25](https://github.com/vitalets/google-translate-api/pull/25))
- Added support for language extensions from outside of the API (See [#18](https://github.com/vitalets/google-translate-api/pull/18))

## Install 

```
npm install @vitalets/google-translate-api
```

## Usage

From automatic language detection to English:

```js
const translate = require('@vitalets/google-translate-api');

translate('Ik spreek Engels', {to: 'en'}).then(res => {
    console.log(res.text);
    //=> I speak English
    console.log(res.from.language.iso);
    //=> nl
}).catch(err => {
    console.error(err);
});
```

From English to Dutch with a typo:

```js
translate('I spea Dutch!', {from: 'en', to: 'nl'}).then(res => {
    console.log(res.text);
    //=> Ik spreek Nederlands!
    console.log(res.from.text.autoCorrected);
    //=> true
    console.log(res.from.text.value);
    //=> I [speak] Dutch!
    console.log(res.from.text.didYouMean);
    //=> false
}).catch(err => {
    console.error(err);
});
```

Sometimes, the API will not use the auto corrected text in the translation:

```js
translate('I spea Dutch!', {from: 'en', to: 'nl'}).then(res => {
    console.log(res);
    console.log(res.text);
    //=> Ik spea Nederlands!
    console.log(res.from.text.autoCorrected);
    //=> false
    console.log(res.from.text.value);
    //=> I [speak] Dutch!
    console.log(res.from.text.didYouMean);
    //=> true
}).catch(err => {
    console.error(err);
});
```

You can also add languages in the code and use them in the translation:

``` js
translate = require('google-translate-api');
translate.languages['sr-Latn'] = 'Serbian Latin';

translate('translator', {to: 'sr-Latn'}).then(res => ...);
```

## Proxy
Google Translate has request limits. If too many requests are made, you can either end up with a 429 or a 503 error.
You can use **proxy** to bypass them:
```js
const tunnel = require('tunnel');
translate('Ik spreek Engels', {to: 'en'}, {
    agent: tunnel.httpsOverHttp({
    proxy: { 
      host: 'whateverhost',
      proxyAuth: 'user:pass',
      port: '8080',
      headers: {
        'User-Agent': 'Node'
      }
    }
  }
)}).then(res => {
    // do something
}).catch(err => {
    console.error(err);
});
```

## Does it work from web page context?
No. `https://translate.google.com` does not provide [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) http headers allowing access from other domains.

## API

### translate(text, [options], [gotOptions])

#### text

Type: `string`

The text to be translated

#### options

Type: `object`

##### from
Type: `string` Default: `auto`

The `text` language. Must be `auto` or one of the codes/names (not case sensitive) contained in [languages.js](https://github.com/vitalets/google-translate-api/blob/master/languages.js)

##### to
Type: `string` Default: `en`

The language in which the text should be translated. Must be one of the codes/names (case sensitive!) contained in [languages.js](https://github.com/vitalets/google-translate-api/blob/master/languages.js).

##### raw
Type: `boolean` Default: `false`

If `true`, the returned object will have a `raw` property with the raw response (`string`) from Google Translate.

##### client
Type: `string` Default: `"t"`

Query parameter `client` used in API calls. Can be `t|gtx`.

##### tld
Type: `string` Default: `"com"`

TLD for Google translate host to be used in API calls: `https://translate.google.{tld}`.

#### gotOptions
Type: `object`

The got options: https://github.com/sindresorhus/got#options

### Returns an `object`:
- `text` *(string)* – The translated text.
- `from` *(object)*
  - `language` *(object)*
    - `didYouMean` *(boolean)* - `true` if the API suggest a correction in the source language
    - `iso` *(string)* - The [code of the language](https://github.com/vitalets/google-translate-api/blob/master/languages.js) that the API has recognized in the `text`
  - `text` *(object)*
    - `autoCorrected` *(boolean)* – `true` if the API has auto corrected the `text`
    - `value` *(string)* – The auto corrected `text` or the `text` with suggested corrections
    - `didYouMean` *(boolean)* – `true` if the API has suggested corrections to the `text`
- `raw` *(string)* - If `options.raw` is true, the raw response from Google Translate servers. Otherwise, `''`.

Note that `res.from.text` will only be returned if `from.text.autoCorrected` or `from.text.didYouMean` equals to `true`. In this case, it will have the corrections delimited with brackets (`[ ]`):

```js
translate('I spea Dutch').then(res => {
    console.log(res.from.text.value);
    //=> I [speak] Dutch
}).catch(err => {
    console.error(err);
});
```
Otherwise, it will be an empty `string` (`''`).

## Related

- [`vertaler`](https://github.com/matheuss/vertaler) – CLI for this module

## License

MIT © [Matheus Fernandes](http://matheus.top), forked and maintained by [Vitaliy Potapov](https://github.com/vitalets).

import test from 'ava';
import Configstore from 'configstore';
import languages from './languages';
import translate from './index';

const config = new Configstore('google-translate-api');

test.beforeEach(() => {
    config.clear();
});

test('translate without any options', async t => {
    const res = await translate('vertaler');

    t.is(res.text, 'translator');
    t.false(res.from.language.didYouMean);
    t.is(res.from.language.iso, 'nl');
    t.false(res.from.text.autoCorrected);
    t.is(res.from.text.value, '');
    t.false(res.from.text.didYouMean);
});

test('translate from auto to dutch', async t => {
    const res = await translate('translator', {from: 'auto', to: 'nl'});

    t.is(res.text, 'vertaler');
    t.false(res.from.language.didYouMean);
    t.is(res.from.language.iso, 'en');
    t.false(res.from.text.autoCorrected);
    t.is(res.from.text.value, '[translate]');
    t.true(res.from.text.didYouMean);
});

test('test pronunciation', async t => {
    const res = await translate('translator', {from: 'auto', to: 'zh-CN'});

    t.is(res.pronunciation, 'Fānyì zhě');
});

test('translate some english text setting the source language as portuguese', async t => {
    const res = await translate('translator', {from: 'pt', to: 'nl'});

    t.true(res.from.language.didYouMean);
    t.is(res.from.language.iso, 'en');
});

test('translate some misspelled english text to dutch', async t => {
    const res = await translate('I spea Dutch', {from: 'en', to: 'nl'});

    if (res.from.text.autoCorrected || res.from.text.didYouMean) {
        t.is(res.from.text.value, 'I [speak] Dutch');
    } else {
        t.fail();
    }
});

test('translate some text and get the raw output alongside', async t => {
    const res = await translate('vertaler', {raw: true});

    t.truthy(res.raw);
});

test('test a supported language – by code', t => {
    t.true(languages.isSupported('en'));
});

test('test an unsupported language – by code', t => {
    t.false(languages.isSupported('js'));
});

test('test a supported language – by name', t => {
    t.true(languages.isSupported('english'));
});

test('test an unsupported language – by name', t => {
    t.false(languages.isSupported('javascript'));
});

test('get a language code by its name', t => {
    t.is(languages.getCode('english'), 'en');
});

test('get an unsupported language code by its name', t => {
    t.false(languages.getCode('javascript'));
});

test('get a supported language code by code', t => {
    t.is(languages.getCode('en'), 'en');
});

test('call getCode with \'undefined\'', t => {
    t.is(languages.getCode(undefined), false);
});

test('call getCode with \'null\'', t => {
    t.is(languages.getCode(null), false);
});

test('call getCode with an empty string', t => {
    t.is(languages.getCode(''), false);
});

test('call getCode with no arguments', t => {
    t.is(languages.getCode(), false);
});

test('try to translate from an unsupported language', async t => {
    try {
        await translate('something', {from: 'js', to: 'en'});
        t.fail();
    } catch (err) {
        t.is(err.code, 400);
        t.is(err.message, 'The language \'js\' is not supported');
    }
});

test('try to translate to an unsupported language', async t => {
    try {
        await translate('something', {from: 'en', to: 'js'});
        t.fail();
    } catch (err) {
        t.is(err.code, 400);
        t.is(err.message, 'The language \'js\' is not supported');
    }
});

test('translate from dutch to english using language names instead of codes', async t => {
    const res = await translate('iets', {from: 'dutch', to: 'english'});

    t.is(res.from.language.iso, 'nl');
    t.is(res.text, 'something');
});

test('translate via custom tld', async t => {
    const res = await translate('vertaler', {tld: 'cn'});

    t.is(res.text, 'translator');
    t.false(res.from.language.didYouMean);
    t.is(res.from.language.iso, 'nl');
    t.false(res.from.text.autoCorrected);
    t.is(res.from.text.value, '');
    t.false(res.from.text.didYouMean);
});

test('translate via an external language from outside of the API', async t => {
    translate.languages['sr-Latn'] = 'Serbian Latin';
    const res = await translate('translator', {to: 'sr-Latn'});

    t.is(res.text, 'преводилац');
    t.is(res.from.language.iso, 'en');
});

test('pass got options', async t => {
    let a = 0;
    const gotopts = {
        hooks: {
            afterResponse: [
                response => {
                    a++;
                    return response;
                }
            ]
        }
    };
    const res = await translate('vertaler', {}, gotopts);

    t.is(res.text, 'translator');
    t.is(a, 1);
});

test('test get zh code', t => {
    t.false(languages.getCode('zh'));
});

test('test get zh-CN code', t => {
    t.is(languages.getCode('zh-CN'), 'zh-CN');
});

test('test get zh-cn code', t => {
    t.false(languages.getCode('zh-cn'));
});

test('test get zh-TW code', t => {
    t.is(languages.getCode('zh-TW'), 'zh-TW');
});

test('test get zh-tw code', t => {
    t.false(languages.getCode('zh-tw'));
});

test('test zh unsupported', t => {
    t.false(languages.isSupported('zh'));
});

test('test zh-CN supported', t => {
    t.true(languages.isSupported('zh-CN'));
});

test('test zh-cn unsupported', t => {
    t.false(languages.isSupported('zh-cn'));
});

test('test zh-TW supported', t => {
    t.true(languages.isSupported('zh-TW'));
});

test('test zh-tw unsupported', t => {
    t.false(languages.isSupported('zh-tw'));
});

test('test zh-CN supported – by name', t => {
    t.true(languages.isSupported('chinese (simplified)'));
});

# top-most EditorConfig file
root = true

[*]
end_of_line = lf
charset = utf-8
insert_final_newline = true

[*.{js,json}]
indent_style = space
indent_size = 4
trim_trailing_whitespace = true

language: node_js
node_js:
  - '8'

after_success:
  - npm run coverage
var querystring = require('querystring');

var got = require('got');
var token = require('@vitalets/google-translate-token');

var languages = require('./languages');

function translate(text, opts, gotopts) {
    opts = opts || {};
    gotopts = gotopts || {};
    var e;
    [opts.from, opts.to].forEach(function (lang) {
        if (lang && !languages.isSupported(lang)) {
            e = new Error();
            e.code = 400;
            e.message = 'The language \'' + lang + '\' is not supported';
        }
    });
    if (e) {
        return new Promise(function (resolve, reject) {
            reject(e);
        });
    }

    opts.from = opts.from || 'auto';
    opts.to = opts.to || 'en';
    opts.tld = opts.tld || 'com';

    opts.from = languages.getCode(opts.from);
    opts.to = languages.getCode(opts.to);

    return token.get(text, {tld: opts.tld}).then(function (token) {
        var url = 'https://translate.google.' + opts.tld + '/translate_a/single';
        var data = {
            client: opts.client || 't',
            sl: opts.from,
            tl: opts.to,
            hl: opts.to,
            dt: ['at', 'bd', 'ex', 'ld', 'md', 'qca', 'rw', 'rm', 'ss', 't'],
            ie: 'UTF-8',
            oe: 'UTF-8',
            otf: 1,
            ssel: 0,
            tsel: 0,
            kc: 7,
            q: text
        };
        data[token.name] = token.value;

        return url + '?' + querystring.stringify(data);
    }).then(function (url) {
        return got(url, gotopts).then(function (res) {
            var result = {
                text: '',
                pronunciation: '',
                from: {
                    language: {
                        didYouMean: false,
                        iso: ''
                    },
                    text: {
                        autoCorrected: false,
                        value: '',
                        didYouMean: false
                    }
                },
                raw: ''
            };

            if (opts.raw) {
                result.raw = res.body;
            }

            var body = JSON.parse(res.body);
            body[0].forEach(function (obj) {
                if (obj[0]) {
                    result.text += obj[0];
                }
                if (obj[2]) {
                    result.pronunciation += obj[2];
                }
            });

            if (body[2] === body[8][0][0]) {
                result.from.language.iso = body[2];
            } else {
                result.from.language.didYouMean = true;
                result.from.language.iso = body[8][0][0];
            }

            if (body[7] && body[7][0]) {
                var str = body[7][0];

                str = str.replace(/<b><i>/g, '[');
                str = str.replace(/<\/i><\/b>/g, ']');

                result.from.text.value = str;

                if (body[7][5] === true) {
                    result.from.text.autoCorrected = true;
                } else {
                    result.from.text.didYouMean = true;
                }
            }

            return result;
        }).catch(function (err) {
            err.message += `\nUrl: ${url}`;
            if (err.statusCode !== undefined && err.statusCode !== 200) {
                err.code = 'BAD_REQUEST';
            } else {
                err.code = 'BAD_NETWORK';
            }
            throw err;
        });
    });
}

module.exports = translate;
module.exports.languages = languages;

/**
 *
 * Generated from https://translate.google.com
 *
 * The languages that Google Translate supports (as of 5/15/16) alongside with their ISO 639-1 codes
 * See https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes
 */

var langs = {
    'auto': 'Automatic',
    'af': 'Afrikaans',
    'sq': 'Albanian',
    'am': 'Amharic',
    'ar': 'Arabic',
    'hy': 'Armenian',
    'az': 'Azerbaijani',
    'eu': 'Basque',
    'be': 'Belarusian',
    'bn': 'Bengali',
    'bs': 'Bosnian',
    'bg': 'Bulgarian',
    'ca': 'Catalan',
    'ceb': 'Cebuano',
    'ny': 'Chichewa',
    'zh-CN': 'Chinese (Simplified)',
    'zh-TW': 'Chinese (Traditional)',
    'co': 'Corsican',
    'hr': 'Croatian',
    'cs': 'Czech',
    'da': 'Danish',
    'nl': 'Dutch',
    'en': 'English',
    'eo': 'Esperanto',
    'et': 'Estonian',
    'tl': 'Filipino',
    'fi': 'Finnish',
    'fr': 'French',
    'fy': 'Frisian',
    'gl': 'Galician',
    'ka': 'Georgian',
    'de': 'German',
    'el': 'Greek',
    'gu': 'Gujarati',
    'ht': 'Haitian Creole',
    'ha': 'Hausa',
    'haw': 'Hawaiian',
    'he': 'Hebrew',
    'iw': 'Hebrew',
    'hi': 'Hindi',
    'hmn': 'Hmong',
    'hu': 'Hungarian',
    'is': 'Icelandic',
    'ig': 'Igbo',
    'id': 'Indonesian',
    'ga': 'Irish',
    'it': 'Italian',
    'ja': 'Japanese',
    'jw': 'Javanese',
    'kn': 'Kannada',
    'kk': 'Kazakh',
    'km': 'Khmer',
    'ko': 'Korean',
    'ku': 'Kurdish (Kurmanji)',
    'ky': 'Kyrgyz',
    'lo': 'Lao',
    'la': 'Latin',
    'lv': 'Latvian',
    'lt': 'Lithuanian',
    'lb': 'Luxembourgish',
    'mk': 'Macedonian',
    'mg': 'Malagasy',
    'ms': 'Malay',
    'ml': 'Malayalam',
    'mt': 'Maltese',
    'mi': 'Maori',
    'mr': 'Marathi',
    'mn': 'Mongolian',
    'my': 'Myanmar (Burmese)',
    'ne': 'Nepali',
    'no': 'Norwegian',
    'ps': 'Pashto',
    'fa': 'Persian',
    'pl': 'Polish',
    'pt': 'Portuguese',
    'pa': 'Punjabi',
    'ro': 'Romanian',
    'ru': 'Russian',
    'sm': 'Samoan',
    'gd': 'Scots Gaelic',
    'sr': 'Serbian',
    'st': 'Sesotho',
    'sn': 'Shona',
    'sd': 'Sindhi',
    'si': 'Sinhala',
    'sk': 'Slovak',
    'sl': 'Slovenian',
    'so': 'Somali',
    'es': 'Spanish',
    'su': 'Sundanese',
    'sw': 'Swahili',
    'sv': 'Swedish',
    'tg': 'Tajik',
    'ta': 'Tamil',
    'te': 'Telugu',
    'th': 'Thai',
    'tr': 'Turkish',
    'uk': 'Ukrainian',
    'ur': 'Urdu',
    'uz': 'Uzbek',
    'vi': 'Vietnamese',
    'cy': 'Welsh',
    'xh': 'Xhosa',
    'yi': 'Yiddish',
    'yo': 'Yoruba',
    'zu': 'Zulu'
};
/**
 * Returns the ISO 639-1 code of the desiredLang – if it is supported by Google Translate
 * @param {string} desiredLang – the name or the code(case sensitive) of the desired language
 * @returns {string|boolean} The ISO 639-1 code of the language or false if the language is not supported
 */
function getCode(desiredLang) {
    if (!desiredLang) {
        return false;
    }

    if (langs[desiredLang]) {
        return desiredLang;
    }

    var keys = Object.keys(langs).filter(function (key) {
        if (typeof langs[key] !== 'string') {
            return false;
        }

        return langs[key].toLowerCase() === desiredLang.toLowerCase();
    });

    return keys[0] || false;
}

/**
 * Returns true if the desiredLang is supported by Google Translate and false otherwise
 * @param desiredLang – the ISO 639-1 code or the name of the desired language
 * @returns {boolean}
 */
function isSupported(desiredLang) {
    return Boolean(getCode(desiredLang));
}

module.exports = langs;
module.exports.isSupported = isSupported;
module.exports.getCode = getCode;
